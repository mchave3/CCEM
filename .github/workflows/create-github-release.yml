name: üöÄ Create GitHub Release

on:
  workflow_call:
    inputs:
      version:
        description: 'Version string (e.g., 2510.1 or 2510-Beta.1)'
        required: true
        type: string
      tag-name:
        description: 'Git tag name (e.g., v2510.1)'
        required: true
        type: string
      release-name:
        description: 'GitHub Release name'
        required: true
        type: string
      source-commit:
        description: 'Source commit SHA to tag'
        required: true
        type: string
      is-prerelease:
        description: 'Whether this is a prerelease (beta)'
        required: true
        type: boolean
      release-body-template:
        description: 'Path to release body template (markdown file)'
        required: true
        type: string
      velopack-output-dir:
        description: 'Directory containing Velopack releases'
        required: true
        type: string
      artifact-name:
        description: 'Name of the Velopack artifact to download'
        required: true
        type: string
      msix-dir:
        description: 'Directory containing MSIX files (optional)'
        required: false
        type: string
        default: ''
      pr-number:
        description: 'Pull request number (for beta releases)'
        required: false
        type: number
        default: 0
      pr-title:
        description: 'Pull request title (for beta releases)'
        required: false
        type: string
        default: ''
      pr-author:
        description: 'Pull request author username (for beta releases)'
        required: false
        type: string
        default: ''
      pr-body:
        description: 'Pull request body/description (for beta releases)'
        required: false
        type: string
        default: ''
      previous-stable-tag:
        description: 'Previous stable tag (for stable releases changelog)'
        required: false
        type: string
        default: ''
    outputs:
      release-url:
        description: 'URL of the created GitHub Release'
        value: ${{ jobs.release.outputs.release-url }}

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: pwsh
    outputs:
      release-url: ${{ steps.release-url.outputs.url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Velopack artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact-name }}
          path: downloaded-artifacts/velopack-releases

      - name: List downloaded artifacts
        shell: pwsh
        run: |
          Write-Host "## Downloaded Artifacts" >> $env:GITHUB_STEP_SUMMARY
          if (Test-Path "downloaded-artifacts") {
            Get-ChildItem -Path "downloaded-artifacts" -Recurse -File | ForEach-Object {
              Write-Host "* ``$($_.FullName)``" >> $env:GITHUB_STEP_SUMMARY
            }
          }

      - name: Calculate hashes & generate FILES_TABLE
        id: files-table
        shell: pwsh
        run: |
          $repo = "${{ github.repository }}"
          $ver = "${{ inputs.version }}"
          $rows = @()

          $collect = @()

          # This directory contains only the final Velopack packages
          $velopackDir = "downloaded-artifacts/velopack-releases"

          if (Test-Path $velopackDir) {
            Write-Host "Collecting files from Velopack output directory: $velopackDir"
            $collect += Get-ChildItem -Path $velopackDir -File
          } else {
            Write-Host "‚ö†Ô∏è Velopack directory not found: $velopackDir"
          }

          # Collect MSIX files if directory is specified and exists
          if ("${{ inputs.msix-dir }}" -ne "" -and (Test-Path "${{ inputs.msix-dir }}")) {
            $collect += Get-ChildItem -Path "${{ inputs.msix-dir }}" -File -Recurse
          }

          # Filter out .json files from FILES_TABLE
          $collect = $collect | Where-Object { $_.Extension -ne ".json" }

          Write-Host "Found $($collect.Count) files for FILES_TABLE (excluding .json files)"

          foreach ($f in ($collect | Sort-Object Name)) {
            $hash = (Get-FileHash $f.FullName -Algorithm SHA256).Hash
            $dl = "https://github.com/$repo/releases/download/${{ inputs.tag-name }}/$($f.Name)"
            $badge = "https://img.shields.io/github/downloads/$repo/${{ inputs.tag-name }}/$($f.Name)?style=flat-square&label=&color=blue"
            $rows += "|[$($f.Name)]($dl)|``$hash``|<picture>![$($f.Name)]($badge)</picture>|"
            Write-Host "  - $($f.Name)"
          }

          $table = @"
          ## Files
          |Files|Hash (SHA256)|Downloads|
          |---|---|---|
          $($rows -join "`n")
          "@

          # Use multiline output
          "files_table<<EOF" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8
          $table | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8
          "EOF" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Generate release body from template
        id: release-body
        shell: pwsh
        run: |
          $templatePath = "${{ inputs.release-body-template }}"

          if (-not (Test-Path $templatePath)) {
            Write-Host "‚ùå Release body template not found: $templatePath"
            exit 1
          }

          $templateContent = Get-Content -Path $templatePath -Raw
          $body = $templateContent

          # Replace common placeholders
          $repoFullName = "${{ github.repository }}"
          $repoParts = $repoFullName -split "/"
          $repoOwner = $repoParts[0]
          $repoName = $repoParts[1]

          $body = $body -replace '\{VERSION\}',"${{ inputs.version }}"
          $body = $body -replace '\{REPO_OWNER\}',$repoOwner
          $body = $body -replace '\{REPO_NAME\}',$repoName

          # For beta releases: use PR information
          if ("${{ inputs.is-prerelease }}" -eq "True" -and "${{ inputs.pr-number }}" -ne "0") {
            Write-Host "Processing beta release with PR information"

            $body = $body -replace '\{PR_TITLE\}',"${{ inputs.pr-title }}"
            $body = $body -replace '\{PR_AUTHOR\}',"${{ inputs.pr-author }}"
            $body = $body -replace '\{PR_NUMBER\}',"${{ inputs.pr-number }}"
            $body = $body -replace '\{PR_REPO_OWNER\}',$repoOwner
            $body = $body -replace '\{PR_REPO_NAME\}',$repoName

            # Handle PR body (description)
            $prBody = @"
          ${{ inputs.pr-body }}
          "@
            if ([string]::IsNullOrWhiteSpace($prBody)) {
              $prBody = "_No description provided_"
            }
            $body = $body -replace '\{PR_BODY\}',$prBody
          }

          # For stable releases: generate changelog
          if ("${{ inputs.is-prerelease }}" -eq "False" -and "${{ inputs.previous-stable-tag }}" -ne "") {
            Write-Host "Processing stable release - generating changelog"

            # Get all merge commits since last stable tag
            $fromTag = "${{ inputs.previous-stable-tag }}"
            $logOutput = git log "$fromTag..HEAD" --merges --pretty=format:"%s|%an" --first-parent

            $changelog = ""
            if ([string]::IsNullOrEmpty($logOutput)) {
              $changelog = "_No changes recorded_"
            } else {
              $prEntries = @()

              foreach ($line in $logOutput -split "`n") {
                if ($line -match "Merge pull request #(\d+) from (.+)\|(.+)") {
                  $prNumber = $Matches[1]
                  $branch = $Matches[2]
                  $authorName = $Matches[3]

                  # Extract username from branch
                  $username = if ($branch -match "^([^/]+)/") { $Matches[1] } else { $authorName }

                  # Get PR title
                  $prTitle = git log "$fromTag..HEAD" --grep="Merge pull request #$prNumber" --format=%B -n 1 | Select-Object -Skip 2 -First 1
                  if ([string]::IsNullOrWhiteSpace($prTitle)) {
                    $prTitle = "Pull Request #$prNumber"
                  }
                  $prTitle = $prTitle.Trim()

                  $entry = "* **$prTitle** by [@$username](https://github.com/$username) - [#$prNumber](https://github.com/$repoOwner/$repoName/pull/$prNumber)"
                  $prEntries += $entry
                }
              }

              if ($prEntries.Count -eq 0) {
                $changelog = "_No pull requests found_"
              } else {
                $changelog = $prEntries -join "`n"
              }
            }

            $body = $body -replace '\{CHANGELOG\}',$changelog
            $body = $body -replace '\{PREVIOUS_TAG\}',"${{ inputs.previous-stable-tag }}"
          }

          # Replace FILES_TABLE placeholder
          $body = $body -replace '\{FILES_TABLE\}',"${{ steps.files-table.outputs.files_table }}"

          # Save to file
          $outputPath = "generated-release-body.md"
          $body | Out-File -FilePath $outputPath -Encoding UTF8 -NoNewline

          Write-Host "‚úÖ Release body generated successfully"

          "body_path=$outputPath" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Prepare release files
        id: prepare-files
        shell: pwsh
        run: |
          # Create a staging directory for release files
          $stagingDir = "release-staging"
          New-Item -ItemType Directory -Force -Path $stagingDir | Out-Null

          # Copy only Velopack files (not all artifacts)
          $velopackDir = "downloaded-artifacts/velopack-releases"

          if (Test-Path $velopackDir) {
            Write-Host "Copying Velopack files from: $velopackDir"
            Get-ChildItem -Path $velopackDir -File | ForEach-Object {
              Copy-Item $_.FullName -Destination $stagingDir -Force
              Write-Host "  Copied: $($_.Name)"
            }
          } else {
            Write-Host "‚ö†Ô∏è Velopack directory not found: $velopackDir"
          }

          # Copy MSIX files if available
          if ("${{ inputs.msix-dir }}" -ne "" -and (Test-Path "${{ inputs.msix-dir }}")) {
            Write-Host "Copying MSIX files from: ${{ inputs.msix-dir }}"
            Get-ChildItem -Path "${{ inputs.msix-dir }}" -File -Recurse | ForEach-Object {
              Copy-Item $_.FullName -Destination $stagingDir -Force
              Write-Host "  Copied: $($_.Name)"
            }
          }

          $fileCount = (Get-ChildItem -Path $stagingDir -File).Count
          Write-Host "‚úÖ Total files prepared for release: $fileCount"

          "staging-dir=$stagingDir" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Create Git tag & GitHub Release
        id: gh-release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.tag-name }}
          name: ${{ inputs.release-name }}
          target_commitish: ${{ inputs.source-commit }}
          prerelease: ${{ inputs.is-prerelease }}
          files: ${{ steps.prepare-files.outputs.staging-dir }}/*
          body_path: ${{ steps.release-body.outputs.body_path }}

      - name: Calculate release URL
        id: release-url
        shell: pwsh
        run: |
          $url = "https://github.com/${{ github.repository }}/releases/tag/${{ inputs.tag-name }}"
          "url=$url" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "Release URL: $url"

      - name: Release Summary
        shell: pwsh
        run: |
          Write-Host "## Release Summary" >> $env:GITHUB_STEP_SUMMARY
          Write-Host "* **Version**: ``${{ inputs.version }}``" >> $env:GITHUB_STEP_SUMMARY
          Write-Host "* **Tag**: ``${{ inputs.tag-name }}``" >> $env:GITHUB_STEP_SUMMARY
          Write-Host "* **Prerelease**: ``${{ inputs.is-prerelease }}``" >> $env:GITHUB_STEP_SUMMARY
          Write-Host "* **Release URL**: ${{ steps.release-url.outputs.url }}" >> $env:GITHUB_STEP_SUMMARY
