name: ðŸš€ Create GitHub Release

on:
  workflow_call:
    inputs:
      version:
        description: 'Version string (e.g., 25.11.2 or 25.11.0-beta.3)'
        required: true
        type: string
      tag-name:
        description: 'Git tag name (e.g., v25.11.2)'
        required: true
        type: string
      release-name:
        description: 'GitHub Release name'
        required: true
        type: string
      source-commit:
        description: 'Source commit SHA to tag'
        required: true
        type: string
      is-prerelease:
        description: 'Whether this is a prerelease (beta)'
        required: true
        type: boolean
      artifact-name:
        description: 'Name of the Velopack artifact to download'
        required: true
        type: string
      msix-dir:
        description: 'Directory containing MSIX files (optional)'
        required: false
        type: string
        default: ''
    outputs:
      release-url:
        description: 'URL of the created GitHub Release'
        value: ${{ jobs.release.outputs.release-url }}

permissions:
  contents: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: pwsh
    outputs:
      release-url: ${{ steps.release-url.outputs.url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Fetch all tags
        run: git fetch --force --tags

      - name: Download Velopack artifacts
        uses: actions/download-artifact@v7
        with:
          name: ${{ inputs.artifact-name }}
          path: downloaded-artifacts/velopack-releases

      - name: List downloaded artifacts
        shell: pwsh
        run: |
          Write-Host "## Downloaded Artifacts" >> $env:GITHUB_STEP_SUMMARY
          if (Test-Path "downloaded-artifacts") {
            Get-ChildItem -Path "downloaded-artifacts" -Recurse -File | ForEach-Object {
              Write-Host "* ``$($_.FullName)``" >> $env:GITHUB_STEP_SUMMARY
            }
          }

      - name: Calculate previous tag for release notes
        id: previous-tag
        shell: pwsh
        run: |
          $currentTag = "${{ inputs.tag-name }}"

          $stablePattern = '^v(\d{2})\.(\d{1,2})\.(\d+)$'
          $betaPattern   = '^v(\d{2})\.(\d{1,2})\.0-beta\.(\d+)$'

          function Get-LatestStableTag([string[]]$allTags, [int]$beforeYY = 999, [int]$beforeMM = 99) {
            # Find the latest stable tag, optionally before a given YY.MM version line
            $stableTags = $allTags | ForEach-Object {
              $m = [regex]::Match($_, $stablePattern)
              if ($m.Success) {
                [pscustomobject]@{
                  Tag   = $_
                  YY    = [int]$m.Groups[1].Value
                  MM    = [int]$m.Groups[2].Value
                  Patch = [int]$m.Groups[3].Value
                }
              }
            } | Where-Object { $_.YY -lt $beforeYY -or ($_.YY -eq $beforeYY -and $_.MM -lt $beforeMM) }

            if (-not $stableTags) { return "" }
            return ($stableTags | Sort-Object YY, MM, Patch -Descending | Select-Object -First 1).Tag
          }

          $allTags = @(git tag --list 'v*')
          Write-Host "Found $($allTags.Count) tags matching 'v*'"
          $previousTag = ""

          if ($currentTag -match $betaPattern) {
            $yy = [int]$Matches[1]
            $mm = [int]$Matches[2]
            $build = [int]$Matches[3]

            Write-Host "Beta detected: YY=$yy, MM=$mm, Build=$build"

            # Look for previous beta in same version line
            $sameLineBetaPattern = "^v$yy\.$mm\.0-beta\.(\d+)$"
            $previousBuild = $allTags | ForEach-Object {
              $m = [regex]::Match($_, $sameLineBetaPattern)
              if ($m.Success) { [int]$m.Groups[1].Value }
            } | Where-Object { $_ -lt $build } | Sort-Object -Descending | Select-Object -First 1

            if ($previousBuild) {
              $previousTag = "v$yy.$mm.0-beta.$previousBuild"
              Write-Host "Found previous beta: $previousTag"
            } else {
              # No previous beta, get latest stable overall
              $previousTag = Get-LatestStableTag -allTags $allTags
              Write-Host "No previous beta, using latest stable: $previousTag"
            }
          }
          elseif ($currentTag -match $stablePattern) {
            $yy = [int]$Matches[1]
            $mm = [int]$Matches[2]
            $patch = [int]$Matches[3]

            Write-Host "Stable detected: YY=$yy, MM=$mm, Patch=$patch"

            # Look for previous patch in same version line
            $sameLineStablePattern = "^v$yy\.$mm\.(\d+)$"
            $previousPatch = $allTags | ForEach-Object {
              $m = [regex]::Match($_, $sameLineStablePattern)
              if ($m.Success) { [int]$m.Groups[1].Value }
            } | Where-Object { $_ -lt $patch } | Sort-Object -Descending | Select-Object -First 1

            if ($previousPatch) {
              $previousTag = "v$yy.$mm.$previousPatch"
              Write-Host "Found previous patch: $previousTag"
            } else {
              # No previous patch, get latest stable before this version line
              $previousTag = Get-LatestStableTag -allTags $allTags -beforeYY $yy -beforeMM $mm
              Write-Host "No previous patch, using latest stable before ${yy}.${mm}: $previousTag"
            }
          }

          "tag=$previousTag" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8

          Write-Host "Current tag:  $currentTag"
          if ([string]::IsNullOrWhiteSpace($previousTag)) {
            Write-Host "Previous tag: (auto)"
          } else {
            Write-Host "Previous tag: $previousTag"
          }

      - name: Prepare release files
        id: prepare-files
        shell: pwsh
        run: |
          # Create a staging directory for release files
          $stagingDir = "release-staging"
          New-Item -ItemType Directory -Force -Path $stagingDir | Out-Null

          # Copy only Velopack files (not all artifacts)
          $velopackDir = "downloaded-artifacts/velopack-releases"

          if (Test-Path $velopackDir) {
            Write-Host "Copying Velopack files from: $velopackDir"
            Get-ChildItem -Path $velopackDir -File | ForEach-Object {
              Copy-Item $_.FullName -Destination $stagingDir -Force
              Write-Host "  Copied: $($_.Name)"
            }
          } else {
            Write-Host "âš ï¸ Velopack directory not found: $velopackDir"
          }

          # Copy MSIX files if available
          if ("${{ inputs.msix-dir }}" -ne "" -and (Test-Path "${{ inputs.msix-dir }}")) {
            Write-Host "Copying MSIX files from: ${{ inputs.msix-dir }}"
            Get-ChildItem -Path "${{ inputs.msix-dir }}" -File -Recurse | ForEach-Object {
              Copy-Item $_.FullName -Destination $stagingDir -Force
              Write-Host "  Copied: $($_.Name)"
            }
          }

          $fileCount = (Get-ChildItem -Path $stagingDir -File).Count
          Write-Host "? Total files prepared for release: $fileCount"

          "staging-dir=$stagingDir" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Create GitHub Release (forced previous tag)
        id: gh-release-forced
        if: steps.previous-tag.outputs.tag != ''
        uses: ncipollo/release-action@v1.20.0
        with:
          tag: ${{ inputs.tag-name }}
          name: ${{ inputs.release-name }}
          commit: ${{ inputs.source-commit }}
          prerelease: ${{ inputs.is-prerelease }}
          artifacts: ${{ steps.prepare-files.outputs.staging-dir }}/*
          generateReleaseNotes: true
          generateReleaseNotesPreviousTag: ${{ steps.previous-tag.outputs.tag }}

      - name: Create GitHub Release (auto previous tag)
        id: gh-release-auto
        if: steps.previous-tag.outputs.tag == ''
        uses: ncipollo/release-action@v1.20.0
        with:
          tag: ${{ inputs.tag-name }}
          name: ${{ inputs.release-name }}
          commit: ${{ inputs.source-commit }}
          prerelease: ${{ inputs.is-prerelease }}
          artifacts: ${{ steps.prepare-files.outputs.staging-dir }}/*
          generateReleaseNotes: true

      - name: Calculate release URL
        id: release-url
        shell: pwsh
        run: |
          $url = "https://github.com/${{ github.repository }}/releases/tag/${{ inputs.tag-name }}"
          "url=$url" | Out-File $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "Release URL: $url"

      - name: Release Summary
        shell: pwsh
        run: |
          Write-Host "## Release Summary" >> $env:GITHUB_STEP_SUMMARY
          Write-Host "* **Version**: ``${{ inputs.version }}``" >> $env:GITHUB_STEP_SUMMARY
          Write-Host "* **Tag**: ``${{ inputs.tag-name }}``" >> $env:GITHUB_STEP_SUMMARY
          Write-Host "* **Prerelease**: ``${{ inputs.is-prerelease }}``" >> $env:GITHUB_STEP_SUMMARY
          Write-Host "* **Release URL**: ${{ steps.release-url.outputs.url }}" >> $env:GITHUB_STEP_SUMMARY
